# TransE算法

[TOC]

------

## 算法思想

- **核心思想:** 把三元组转化成低维向量，这个向量我们叫做embedding向量，变成向量之后就可以用很多数学方法进行进一步的处理

  >  原始的数据是三元组形式(h, r, t)，希望找到某种算法能把h，r，t分别转换为向量，类似[0.01, 0.04, 0.8, 0.32, 0.09, 0.18]，并且让$h+r \approx t$，(把r看作是从h到t的translating)

  

- **目标函数：**$min(h,r,t) \in S\sum(h',r,t') \in S'\sum[\gamma + d(h+r,t) - d(h' + r, t')]_+$

  ​				$\gamma$: 正负样本之间的间距（常数）

  ​				$[x]_+$: max(0, x)

  > 在判断$h+r \approx t$时我们采用距离进行衡量$d(x,y)$
  >
  > 对于正确的三元组(h,r,t)，距离$d(h+r,r)$越小越好，对于错误的三元组$d(h'+r,t')$越大越好

  

  - **约束条件：**$||h||≤1,||r||≤1,||t||≤1$，避免过拟合

- **简单思路：**

  >  对于每一个实体：
  >
  > 1. 首先将它随机初始化为规定维数的一个向量，之后不断按照如下步骤进行修正，得到embedding向量
  > 2. 从训练三元组中随机抽出b个向量，对于每个三元组进行打碎（随机替换头或尾，但不能同时替换）
  > 3. 之后计算势能函数，进行梯度下降算法更新h，r，t

------

## 算法逻辑

- 随机初始化头实体、尾实体和关系向量，并对随机初始化的向量做归一化处理；
- 对数据集中的三元组抽样，并对抽样的三元组进行实体替换，形成负例；
- 利用随机梯度下降法不断优化实体和关系的向量表示。

**具体算法**：
![Algorithm1](https://note.youdao.com/yws/public/resource/7d0b21f628276bbf894e465b25bb8c10/xmlnote/D003C796AAD24A1DB8295BD8EBF8B2EB/3695)

**代码实现**：

- 调用`_init_()`初始化算法所用到的三元组、向量维度、距离计算公式等


- 调用`initialize(self)`初始化向量

  1.通过函数`uniform(-6/math.sqrt(self.k),6/math.sqrt(self.k))`对于每一个entity和relation的每一维进行随机取值
    
    2.利用`norm()`对向量归一化
    
- 调用`train(self,cI)`进行循环训练（cI：训练次数）

    1. 通过`sample()`对三元组进行随机取样并存入`Sbatch[]`

    2. 对于`Sbatch[]`中的每一个三元组调用函数`getCorruptedTriplet(self,triplet)`进行打碎，并将原三元组和打碎的三元组存入Tbatch[]。
         打碎过程：随机替换head或trail，并保证替换前后entity不相同,即打碎前后三元组不相同。
         注：不能同时替换head和trail，否则不具备对照性。
       1. 调用`update(self,Tbatch)`修正三元组。
            对于`Tbatch[]`中的所有三元组对利用L1或L2公式（欧几里得/哈夫曼距离公式）计算距离并得出loss。`(self.margin + distTriplet - distCorruptedTriplet)`
            对于Tbatch中的三元组对分别计算梯度$2*learingRate*(h+r-t)$，并根据梯度更新三元组对，保证原三元组距离d越来越小而打碎的三元组距离d越来越大。

------

## 关键问题

### 1. 如何生成错误的三元组？

 随机替换head或trail，并保证替换前后entity不相同,即打碎前后三元组不相同。

为了避免出现生成的负例其实存在于知识库中的情况，我们可以对生成的负例进行过滤，如果它是知识库中的正例，那我们就不把它作为负例，而是重新生成一个负例。

> **为什么不能同时打碎头和尾？**
>
> 不具备对照性。

### 2. 如何根据梯度下降修正三元组？

https://blog.csdn.net/weixin_42348333/article/details/89598144

**势能函数：**对于正确的三元组，势能越低越好；对于错误的三元组，势能越高越好(这里的势能是通过所谓的距离刻画的)

>  有两种势能函数(距离)的表示形式
>
> - 二范数：
>
>   $$ f(h,r,t) = ||h+r-t||_2 $$
>
>   $$ ||\textbf{x}||*2 =\sqrt{\sum*{i=1}^Nx_i^2} $$
>
> - 欧几里得范数：向量绝对值的平方和（再开方）

这个还没太看懂$\downarrow$

![image-20191128160014620](../../../../Library/Application Support/typora-user-images/image-20191128160014620.png)

### 3. validation和test的使用？

validation：验证集，用来对训练后的模型进行验证、调参，选出最好的模型。

test：测试集，对验证集选出的模型进行测试。

将三元组的头实体被字典中的每个实体轮流替换。首先通过模型计算这些替换元组的距离，然后按升序排列；最后存储正确实体的排名。重复这个过程，把移去头用移去尾代替。记录这些预测排名的平均值和hits@10，也就是，排在前10的正确实体的比例。

### 4. 如何检验？

假设整个知识库中一共有n个实体，那么评价过程如下：

- 将一个正确的三元组a中的头实体或者尾实体，依次替换为整个知识库中的所有其它实体，也就是会产生n个三元组。
- 分别对上述n个三元组计算其能量值，在transE中，就是计算h+r-t的值。这样可以得到n个能量值，分别对应上述n个三元组。
- 对上述n个能量值进行升序排序。
- 记录三元组a的能量值排序后的序号。
- 对所有的正确的三元组重复上述过程。
- 每个正确三元组的能量值排序后的序号求平均，得到的值我们称为Mean Rank。
- 计算正确三元组的能量排序后的序号小于10的比例，得到的值我们称为Hits@10。

**两个指标：**

- Mean Rank：衡量的是算法对所有三元组的整体效果（越小越好）
- Hits@10：衡量的是算法效果好的程度【个人理解大致是算法的精度】（越大越好）

**改进：**

上述过程存在一个不合理的地方：在将一个正确的三元组a的头或者尾实体替换成其它实体之后得到的这个三元组也有可能是正确的，在计算每个三元组的能量并排序之后，这类正确的三元组的能量有可能排在三元组a的前面。但是上面所说的基本评价过程并没有考虑这点。因此我们把上述基本评价过程得到的结果称为Raw Mean Rank和Raw Hits@10，把改进方法得到的结果称为Filtered Mean Rank和Filtered Hits@10。

为了更好的评价embedding的质量，我们对上述方法进行改进。

- 将一个正确的三元组a中的头实体或者尾实体，依次替换为整个知识库中的所有其它实体，也就是会产生n个三元组。
- 分别对上述n个三元组计算其能量值，在transE中，就是计算h+r-t的值。这样可以得到n个能量值，分别对应上述n个三元组。
- 对上述n个能量值进行升序排序。
- 记录三元组a的能量值排序后的序号k。
- 如果前k-1个能量对应的三元组中有m个三元组也是正确的，那么三元组a的序号改为k-m。
- 对所有的正确的三元组重复上述过程。
- 每个正确三元组的能量值排序后的序号求平均，得到的值我们称为Filtered Mean Rank。
- 计算正确三元组的能量排序后的序号小于10的比例，得到的值我们称为Filtered Hits@10。